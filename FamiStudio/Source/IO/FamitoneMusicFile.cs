using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace FamiStudio
{
    public class FamitoneMusicFile
    {
        private Project project;

        private List<string> lines = new List<string>();

        private string db = ".byte";
        private string dw = ".word";
        private string ll = "@";
        private string lo = ".lobyte";
        private string hi = ".hibyte";

        private int machine = MachineType.NTSC;
        private int assemblyFormat = AssemblyFormat.NESASM;
        private Dictionary<byte, string> vibratoEnvelopeNames = new Dictionary<byte, string>();
        private Dictionary<Arpeggio, string> arpeggioEnvelopeNames = new Dictionary<Arpeggio, string>();
        private Dictionary<Instrument, int> instrumentIndices = new Dictionary<Instrument, int>();
        private string noArpeggioEnvelopeName;

        private int kernel = FamiToneKernel.FamiStudio;

        private bool log = true;
        private int maxRepeatCount = MaxRepeatCountFT2;

        private const int MinPatternLength = 6;
        private const int MaxRepeatCountFT2FS = 59; // 1 less for release notes.
        private const int MaxRepeatCountFT2   = 60;
        private const int MaxSongs = (256 - 5) / 14;
        private const int MaxPatterns = 128 * MaxSongs;
        private const int MaxPackedPatterns = (5 * MaxPatterns * MaxSongs);

        private bool usesFamiTrackerTempo = false;
        private bool usesVolumeTrack = false;
        private bool usesPitchTrack = false;
        private bool usesSlideNotes = false;
        private bool usesVibrato = false;
        private bool usesArpeggio = false;
        private bool usesDutyCycleEffect = false;
        private bool usesDelayedNotesOrCuts = false;

        public FamitoneMusicFile(int kernel, bool outputLog)
        {
            this.log = outputLog;
            this.kernel = kernel;
            this.maxRepeatCount = kernel == FamiToneKernel.FamiStudio ? MaxRepeatCountFT2FS : MaxRepeatCountFT2;
        }

        private void CleanupEnvelopes()
        {
            // All instruments must have a volume envelope.
            foreach (var instrument in project.Instruments)
            {
                var env = instrument.Envelopes[EnvelopeType.Volume];
                if (env == null)
                {
                    env = new Envelope(EnvelopeType.Volume);
                    instrument.Envelopes[EnvelopeType.Volume] = env;
                }
                if (env.Length == 0 || env.AllValuesEqual(Note.VolumeMax))
                {
                    env.Length  =  1;
                    env.Loop    = -1;
                    env.Release = -1;
                    env.Values[0] = 15;
                }
            }
        }

        private int OutputHeader(bool separateSongs)
        {
            var size = 5;
            var name = Utils.MakeNiceAsmName(separateSongs ? project.Songs[0].Name : project.Name);

            lines.Add($";this file for FamiTone2 library generated by FamiStudio");
            lines.Add("");
            lines.Add($"{name}_music_data:");
            lines.Add($"\t{db} {project.Songs.Count}");
            lines.Add($"\t{dw} {ll}instruments");

            if (project.ExpansionAudio == ExpansionType.Fds ||
                project.ExpansionAudio == ExpansionType.N163 ||
                project.ExpansionAudio == ExpansionType.Vrc7)
            {
                lines.Add($"\t{dw} {ll}instruments_{project.ExpansionAudioShortName.ToLower()}");
                size += 2;
            }

            lines.Add($"\t{dw} {ll}samples-3");

            for (int i = 0; i < project.Songs.Count; i++)
            {
                var song = project.Songs[i];
                var line = $"\t{dw} ";

                for (int chn = 0; chn < song.Channels.Length; ++chn)
                {
                    if (chn > 0)
                        line += ",";
                    line += $"{ll}song{i}ch{chn}";
                }

                if (song.UsesFamiTrackerTempo)
                {
                    int tempoPal  = 256 * song.FamitrackerTempo / (50 * 60 / 24);
                    int tempoNtsc = 256 * song.FamitrackerTempo / (60 * 60 / 24);

                    line += $",{tempoPal},{tempoNtsc}";
                    lines.Add(line);

                    usesFamiTrackerTempo = true;
                }
                else
                {
                    var grooveName = GetGrooveAsmName(song.Groove, song.GroovePaddingMode);
                    lines.Add(line);
                    lines.Add($"\t{db} {lo}({ll}tempo_env_{grooveName}), {hi}({ll}tempo_env_{grooveName}), {(project.PalMode ? 2 : 0)}, 0"); 
                }

                size += song.Channels.Length * 2 + 4;
            }

            lines.Add("");

            if (assemblyFormat == AssemblyFormat.CA65)
            {
                lines.Add($".export {name}_music_data");
                lines.Add($".global FAMISTUDIO_DPCM_PTR");
                lines.Add("");
            }

            return size;
        }

        private byte[] ProcessEnvelope(Envelope env, bool allowReleases, bool newPitchEnvelope)
        {
            // HACK : Pass dummy type here, volume envelopes have been taken care of already.
            if (env.IsEmpty(EnvelopeType.Count))
                return null;

            env.Truncate();

            // Special case for envelopes with a single value (like duty often are).
            // Make them 127 in length so that they update less often.
            if (env.Length == 1 && !env.Relative && env.Release < 0)
            {
                if (newPitchEnvelope)
                    return new byte[] { 0x00, (byte)(192 + env.Values[0]), 0x7f, 0x00, 0x01 };
                else if (allowReleases)
                    return new byte[] { 0x04, (byte)(192 + env.Values[0]), 0x7f, 0x00, 0x01 };
                else
                    return new byte[] { (byte)(192 + env.Values[0]), 0x7f, 0x00, 0x00 } ;
            }

            var data = new byte[256];

            byte ptr = (byte)(allowReleases || newPitchEnvelope ? 1 : 0);
            byte ptr_loop = 0xff;
            byte rle_cnt = 0;
            byte prev_val = (byte)(env.Values[0] + 1);//prevent rle match
            bool found_release = false;

            if (newPitchEnvelope)
                data[0] = (byte)(env.Relative ? 0x80 : 0x00);

            for (int j = 0; j < env.Length; j++)
            {
                byte val;

                if (env.Values[j] < -64)
                    val = unchecked((byte)-64);
                else if (env.Values[j] > 63)
                    val = 63;
                else
                    val = (byte)env.Values[j];

                val += 192;

                if (prev_val != val || j == env.Loop || (allowReleases && j == env.Release) || j == env.Length - 1 || (rle_cnt == 127 && newPitchEnvelope))
                {
                    if (rle_cnt != 0)
                    {
                        if (rle_cnt == 1)
                        {
                            data[ptr++] = prev_val;
                        }
                        else
                        {
                            while (rle_cnt > 127)
                            {
                                data[ptr++] = 127;
                                rle_cnt -= 127;
                            }

                            data[ptr++] = rle_cnt;
                        }

                        rle_cnt = 0;
                    }

                    if (j == env.Loop) ptr_loop = ptr;

                    if (j == env.Release && allowReleases)
                    {
                        // A release implies the end of the loop.
                        Debug.Assert(ptr_loop != 0xff && data[ptr_loop] >= 128); // Cant be jumping back to the middle of RLE.
                        found_release = true;
                        data[ptr++] = 0;
                        data[ptr++] = ptr_loop;
                        data[0] = ptr;
                    }

                    data[ptr++] = val;

                    prev_val = val;
                }
                else
                {
                    ++rle_cnt;
                }
            }

            if (ptr_loop == 0xff || found_release)
            {
                ptr_loop = (byte)(ptr - 1);
            }
            else
            {
                Debug.Assert(data[ptr_loop] >= 128); // Cant be jumping back to the middle of RLE.
            }

            data[ptr++] = 0;
            data[ptr++] = ptr_loop;

            Array.Resize(ref data, ptr);

            return data;
        }

        private int OutputInstruments()
        {
            // Process all envelope, make unique, etc.
            var uniqueEnvelopes = new SortedList<uint, byte[]>();
            var instrumentEnvelopes = new Dictionary<Envelope, uint>();

            var defaultEnv = new byte[] { 0xc0, 0x7f, 0x00, 0x00 };
            var defaultDutyEnv = new byte[] { 0x7f, 0x00, 0x00 }; // This is a "do nothing" envelope, simply loops, never sets a value.
            var defaultPitchEnv = new byte[] { 0x00, 0xc0, 0x7f, 0x00, 0x01 };
            var defaultEnvCRC = CRC32.Compute(defaultEnv);
            var defaultDutyEnvCRC = CRC32.Compute(defaultDutyEnv);
            var defaultPitchEnvCRC = CRC32.Compute(defaultPitchEnv);
            var defaultEnvName = "";
            var defaultPitchEnvName = "";

            uniqueEnvelopes.Add(defaultEnvCRC, defaultEnv);

            if (kernel == FamiToneKernel.FamiStudio)
            {
                uniqueEnvelopes.Add(defaultDutyEnvCRC, defaultDutyEnv);
                uniqueEnvelopes.Add(defaultPitchEnvCRC, defaultPitchEnv);
            }

            foreach (var instrument in project.Instruments)
            {
                for (int i = 0; i < EnvelopeType.Count; i++)
                {
                    var env = instrument.Envelopes[i];

                    if (env == null)
                        continue;

                    if (kernel != FamiToneKernel.FamiStudio && i == EnvelopeType.DutyCycle)
                        continue;

                    byte[] processed;

                    switch (i)
                    {
                        case EnvelopeType.N163Waveform:
                            processed = env.BuildN163Waveform();
                            break;
                        case EnvelopeType.FdsModulation:
                            processed = env.BuildFdsModulationTable().Select(m => (byte)m).ToArray();
                            break;
                        case EnvelopeType.FdsWaveform:
                            processed = env.Values.Take(env.Length).Select(m => (byte)m).ToArray();
                            break;
                        default:
                            processed = ProcessEnvelope(env,
                                i == EnvelopeType.Volume && kernel == FamiToneKernel.FamiStudio,
                                i == EnvelopeType.Pitch  && kernel == FamiToneKernel.FamiStudio);
                            break;
                    }

                    if (processed == null)
                    {
                        if (kernel == FamiToneKernel.FamiStudio && i == EnvelopeType.Pitch)
                            instrumentEnvelopes[env] = defaultPitchEnvCRC;
                        else if (kernel == FamiToneKernel.FamiStudio && i == EnvelopeType.DutyCycle)
                            instrumentEnvelopes[env] = defaultDutyEnvCRC;
                        else
                            instrumentEnvelopes[env] = defaultEnvCRC;
                    }
                    else
                    {
                        uint crc = CRC32.Compute(processed);
                        uniqueEnvelopes[crc] = processed;
                        instrumentEnvelopes[env] = crc;
                    }
                }
            }

            // Write the arpeggio envelopes.
            if (kernel == FamiToneKernel.FamiStudio)
            {
                var arpeggioEnvelopes = new Dictionary<Arpeggio, uint>();

                foreach (var arpeggio in project.Arpeggios)
                {
                    var processed = ProcessEnvelope(arpeggio.Envelope, false, false);
                    uint crc = CRC32.Compute(processed);
                    arpeggioEnvelopes[arpeggio] = crc;
                    uniqueEnvelopes[crc] = processed;
                }

                foreach (var arpeggio in project.Arpeggios)
                {
                    arpeggioEnvelopeNames[arpeggio] = $"{ll}env{uniqueEnvelopes.IndexOfKey(arpeggioEnvelopes[arpeggio])}";
                }
            }

            var size = 0;

            // Write instruments
            lines.Add($"{ll}instruments:");

            for (int i = 0, j = 0; i < project.Instruments.Count; i++)
            {
                var instrument = project.Instruments[i];

                if (instrument.ExpansionType != ExpansionType.Fds &&
                    instrument.ExpansionType != ExpansionType.N163 &&
                    instrument.ExpansionType != ExpansionType.Vrc7)
                {
                    var volumeEnvIdx   = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.Volume]]);
                    var arpeggioEnvIdx = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.Arpeggio]]);
                    var pitchEnvIdx    = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.Pitch]]);

                    if (kernel == FamiToneKernel.FamiStudio)
                    {
                        var dutyEnvIdx = instrument.IsEnvelopeActive(EnvelopeType.DutyCycle) ? uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.DutyCycle]]) : uniqueEnvelopes.IndexOfKey(defaultEnvCRC);

                        lines.Add($"\t{dw} {ll}env{volumeEnvIdx},{ll}env{arpeggioEnvIdx},{ll}env{dutyEnvIdx},{ll}env{pitchEnvIdx}");
                    }
                    else
                    {
                        var duty = instrument.IsEnvelopeActive(EnvelopeType.DutyCycle) ? instrument.Envelopes[EnvelopeType.DutyCycle].Values[0] : 0;
                        var dutyShift = instrument.ExpansionType == ExpansionType.None ? 6    : 4;
                        var dutyBits  = instrument.ExpansionType == ExpansionType.None ? 0x30 : 0;

                        lines.Add($"\t{db} ${(duty << dutyShift) | dutyBits:x2} ;instrument {i:x2} ({instrument.Name})");
                        lines.Add($"\t{dw} {ll}env{volumeEnvIdx}, {ll}env{arpeggioEnvIdx}, {ll}env{pitchEnvIdx}");
                        lines.Add($"\t{db} $00");
                    }

                    size += 8;
                    instrumentIndices[instrument] = j++;
                }
            }

            lines.Add("");

            // FDS, N163 and VRC7 instruments are special.
            if (project.ExpansionAudio == ExpansionType.Fds ||
                project.ExpansionAudio == ExpansionType.N163 ||
                project.ExpansionAudio == ExpansionType.Vrc7)
            {
                lines.Add($"{ll}instruments_{project.ExpansionAudioShortName.ToLower()}:");

                for (int i = 0, j = 0; i < project.Instruments.Count; i++)
                {
                    var instrument = project.Instruments[i];

                    if (instrument.ExpansionType != ExpansionType.None)
                    {
                        var volumeEnvIdx   = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.Volume]]);
                        var arpeggioEnvIdx = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.Arpeggio]]);
                        var pitchEnvIdx    = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.Pitch]]);

                        lines.Add($"\t{dw} {ll}env{volumeEnvIdx}, {ll}env{arpeggioEnvIdx}, {ll}env{pitchEnvIdx}");

                        if (instrument.ExpansionType == ExpansionType.Fds)
                        {
                            var fdsWavEnvIdx = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.FdsWaveform]]);
                            var fdsModEnvIdx = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.FdsModulation]]);

                            lines.Add($"\t{db} {instrument.FdsMasterVolume}");
                            lines.Add($"\t{dw} {ll}env{fdsWavEnvIdx}, {ll}env{fdsModEnvIdx}, {instrument.FdsModSpeed}");
                            lines.Add($"\t{db} {instrument.FdsModDepth}, {instrument.FdsModDelay}, $00");
                        }
                        else if (instrument.ExpansionType == ExpansionType.N163)
                        {
                            var n163WaveIdx = uniqueEnvelopes.IndexOfKey(instrumentEnvelopes[instrument.Envelopes[EnvelopeType.N163Waveform]]);

                            lines.Add($"\t{db} ${instrument.N163WavePos / 2:x2}, ${instrument.N163WaveSize / 2:x2}");
                            lines.Add($"\t{dw} {ll}env{n163WaveIdx}");
                            lines.Add($"\t{db} $00, $00, $00, $00, $00, $00");
                        }
                        else if (instrument.ExpansionType == ExpansionType.Vrc7)
                        {
                            lines.Add($"\t{db} ${(instrument.Vrc7Patch << 4):x2}, $00");
                            lines.Add($"\t{db} {String.Join(",", instrument.Vrc7PatchRegs.Select(r => $"${r:x2}"))}");
                        }

                        size += 16;
                        instrumentIndices[instrument] = j++;
                    }
                }

                lines.Add("");
            }

            // Write samples.
            lines.Add($"{ll}samples:");

            if (project.UsesSamples)
            {
                for (int i = 1; i < project.SamplesMapping.Length; i++)
                {
                    var mapping = project.SamplesMapping[i];
                    var sampleOffset = 0;
                    var sampleSize = 0;
                    var samplePitchAndLoop = 0;
                    var sampleName = "";

                    if (mapping != null && mapping.Sample != null)
                    {
                        sampleOffset = Math.Max(0, project.GetAddressForSample(mapping.Sample)) >> 6;
                        sampleSize = mapping.Sample.ProcessedData.Length >> 4;
                        sampleName = $"({mapping.Sample.Name})";
                        samplePitchAndLoop = mapping.Pitch | ((mapping.Loop ? 1 : 0) << 6);
                    }

                    var constName = kernel == FamiToneKernel.FamiStudio ? "FAMISTUDIO_DPCM_PTR" : "FT_DPCM_PTR";

                    size += 3;
                    lines.Add($"\t{db} ${sampleOffset:x2}+{lo}({constName}),${sampleSize:x2},${samplePitchAndLoop:x2}\t;{i} {sampleName}");
                }

                lines.Add("");
            }

            // Write envelopes.
            int idx = 0;
            foreach (var kv in uniqueEnvelopes)
            {
                var name = $"{ll}env{idx++}";
                lines.Add($"{name}:");
                lines.Add($"\t{db} {String.Join(",", kv.Value.Select(i => $"${i:x2}"))}");

                if (kv.Key == defaultEnvCRC)
                    defaultEnvName = name;
                if (kv.Key == defaultPitchEnvCRC)
                    defaultPitchEnvName = name;

                size += kv.Value.Length;
            }

            noArpeggioEnvelopeName = defaultEnvName;

            // Write the unique vibrato envelopes.
            if (kernel == FamiToneKernel.FamiStudio)
            {
                // Create all the unique vibrato envelopes.
                foreach (var s in project.Songs)
                {
                    foreach (var c in s.Channels)
                    {
                        foreach (var p in c.Patterns)
                        {
                            foreach (var note in p.Notes.Values)
                            {
                                if (note.HasVibrato)
                                {
                                    if (note.VibratoDepth == 0 || note.VibratoSpeed == 0)
                                    {
                                        note.RawVibrato = 0;
                                        vibratoEnvelopeNames[0] = defaultPitchEnvName;
                                        continue;
                                    }

                                    var env = Envelope.CreateVibratoEnvelope(note.VibratoSpeed, note.VibratoDepth);
                                    var processed = ProcessEnvelope(env, false, true);
                                    uint crc = CRC32.Compute(processed);
                                    if (!uniqueEnvelopes.ContainsKey(crc))
                                    {
                                        var name = $"{ll}env{idx++}";
                                        lines.Add($"{name}:");
                                        lines.Add($"\t{db} {String.Join(",", processed.Select(i => $"${i:x2}"))}");

                                        uniqueEnvelopes[crc] = processed;
                                        vibratoEnvelopeNames[note.RawVibrato] = name;
                                        size += processed.Length;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return size;
        }

        private string GetGrooveAsmName(int[] groove, int paddingMode)
        {
            var name = string.Join("_", groove);

            switch (paddingMode)
            {
                case GroovePaddingType.Beginning: name += "_beg"; break;
                case GroovePaddingType.Middle:    name += "_mid"; break;
                case GroovePaddingType.End:       name += "_end"; break;
            }

            return name;
        }

        private int OutputTempoEnvelopes()
        {
            var size = 0;

            if (project.UsesFamiStudioTempo)
            {
                var uniqueGrooves = new List<Tuple<int[],int>>();

                foreach (var song in project.Songs)
                {
                    var existintIndex = uniqueGrooves.FindIndex(g => Utils.CompareArrays(g.Item1, song.Groove) == 0 && g.Item2 == song.GroovePaddingMode);
                    if (existintIndex < 0)
                        uniqueGrooves.Add(new Tuple<int[], int>(song.Groove, song.GroovePaddingMode));

                    for (int p = 0; p < song.Length; p++)
                    {
                        if (song.PatternHasCustomSettings(p))
                        {
                            existintIndex = uniqueGrooves.FindIndex(g => Utils.CompareArrays(g.Item1, song.GetPatternGroove(p)) == 0 && g.Item2 == song.GetPatternGroovePaddingMode(p));
                            if (existintIndex < 0)
                                uniqueGrooves.Add(new Tuple<int[], int>(song.GetPatternGroove(p), song.GetPatternGroovePaddingMode(p)));
                        }
                    }
                }

                foreach (var groove in uniqueGrooves)
                {
                    var env = (byte[])FamiStudioTempoUtils.GetTempoEnvelope(groove.Item1, groove.Item2, project.PalMode);

                    lines.Add($"{ll}tempo_env_{GetGrooveAsmName(groove.Item1, groove.Item2)}:");
                    lines.Add($"\t{db} {String.Join(",", env.Select(i => $"${i:x2}"))}");

                    size += env.Length;
                }
            }

            return size;
        }

        private int OutputSamples(string filename, string dmcFilename)
        {
            var samplesSize = 0;

            if (project.UsesSamples)
            {
                var sampleData = project.GetPackedSampleData();

                // TODO: Once we have a real project name, we will use that.
                var path = Path.GetDirectoryName(filename);
                var projectname = Utils.MakeNiceAsmName(project.Name);

                if (dmcFilename == null)
                    dmcFilename = Path.Combine(path, projectname + ".dmc");

                File.WriteAllBytes(dmcFilename, sampleData);

                samplesSize = sampleData.Length;
            }

            return samplesSize;
        }

        private int FindEffectParam(Song song, int patternIdx, int noteIdx, int effect)
        {
            foreach (var channel in song.Channels)
            {
                var pattern = channel.PatternInstances[patternIdx];

                if (pattern != null && 
                    pattern.Notes.TryGetValue(noteIdx, out var note) && 
                    note.HasValidEffectValue(effect))
                {
                    return note.GetEffectValue(effect);
                }
            }

            return -1;
        }

        // If we were using a custom VRC7 patch, but another channel uses one too, 
        // we will need to reload our instrument next time we play a note.
        private bool OtherVrc7ChannelUsesCustomPatch(Song song, Channel channel, Instrument instrument, int patternIdx, int noteIdx)
        {
            if (project.ExpansionAudio == ExpansionType.Vrc7 && 
                channel.IsExpansionChannel &&
                instrument != null &&
                instrument.IsExpansionInstrument &&
                instrument.Vrc7Patch == 0)
            {
                foreach (var c in song.Channels)
                {
                    if (c != channel && c.IsVrc7FmChannel)
                    {
                        var pattern = c.PatternInstances[patternIdx];

                        if (pattern != null && pattern.Notes.TryGetValue(noteIdx, out Note note) &&
                            note != null &&
                            note.Instrument != null &&
                            note.Instrument != instrument &&
                            note.Instrument.IsExpansionInstrument &&
                            note.Instrument.Vrc7Patch == 0)
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        private int FindEffectParam(Song song, int effect)
        {
            for (int p = 0; p < song.Length; p++)
            {
                for (int i = 0; i < song.GetPatternLength(p); i++)
                {
                    int fx = FindEffectParam(song, p, i, effect);
                    if (fx >= 0)
                    {
                        return fx;
                    }
                }
            }

            return -1;
        }

        private int FindEffectPosition(Song song, int patternIdx, int effect)
        {
            for (int i = 0; i < song.GetPatternLength(patternIdx); i++)
            {
                var fx = FindEffectParam(song, patternIdx, i, effect);
                if (fx >= 0)
                {
                    return i;
                }
            }

            return -1;
        }

        private byte EncodeNoteValue(int channel, int value, int numNotes = 0)
        {
            if (kernel != FamiToneKernel.FamiStudio)
            {
                // 0 = stop, 1 = C-1 ... 63 = D-6
                if (value != 0 && channel != ChannelType.Noise) value = Math.Max(1, value - 12); 
                return (byte)(((value & 63) << 1) | numNotes);
            }
            else
            {
                if (value == Note.NoteRelease)
                    return (byte)0xf9;

                // 0 = stop, 1 = C0 ... 96 = B7
                if (value != 0)
                {
                    if (channel == ChannelType.Dpcm)
                        value = Utils.Clamp(value - Note.DPCMNoteMin, 1, 63);
                    else if (channel != ChannelType.Noise)
                        value = Utils.Clamp(value, 1, 96);
                }
                return (byte)(value);
            }
        }

        private List<string> GetSongData(Song song, int songIdx, int speedChannel)
        {
            var songData = new List<string>();
            var emptyPattern = new Pattern(-1, song, 0, "");
            var emptyNote = new Note(Note.NoteInvalid);
            var sb = new StringBuilder();

            for (int c = 0; c < song.Channels.Length; c++)
            {
                var channel = song.Channels[c];
                var currentSpeed = song.FamitrackerSpeed;
                var isSpeedChannel = c == speedChannel;
                var instrument = (Instrument)null;
                var previousGroove = song.Groove;
                var previousGroovePadMode = song.GroovePaddingMode;
                var arpeggio = (Arpeggio)null;
                var sawVolume = Vrc6SawMasterVolumeType.Half;
                var sawVolumeChanged = false;

	            songData.Add($"{ll}song{songIdx}ch{c}:");

                if (isSpeedChannel && project.UsesFamiTrackerTempo)
                {
                    songData.Add("$fb");
                    songData.Add($"{song.FamitrackerSpeed:x2}");
                }

                for (int p = 0; p < song.Length; p++)
                {
                    var pattern = channel.PatternInstances[p] == null ? emptyPattern : channel.PatternInstances[p];

                    if (p == song.LoopPoint)
                    {
                        songData.Add($"{ll}song{songIdx}ch{c}loop:");

                        // Clear stored instrument to force a reset. We might be looping
                        // to a section where the instrument was set from a previous pattern.
                        instrument = null;
                        arpeggio = null;

                        if (sawVolumeChanged)
                            sawVolume = -1;

                        // If this channel potentially uses any arpeggios, clear the override since the last
                        // note may have overridden it. TODO: Actually check if thats the case!
                        if (channel.UsesArpeggios)
                            songData.Add($"${0x66:x2}");
                    }

                    if (isSpeedChannel && project.UsesFamiStudioTempo)
                    {
                        var groove = song.GetPatternGroove(p);
                        var groovePadMode = song.GetPatternGroovePaddingMode(p);

                        if (Utils.CompareArrays(groove, previousGroove) != 0 || 
                            groovePadMode != previousGroovePadMode ||
                            (p == song.LoopPoint && p != 0))
                        {
                            var grooveName = GetGrooveAsmName(groove, groovePadMode);

                            songData.Add("$fb");
                            songData.Add($"{lo}({ll}tempo_env_{grooveName})");
                            songData.Add($"{hi}({ll}tempo_env_{grooveName})");
                            previousGroove = groove;
                            previousGroovePadMode = groovePadMode;
                        }
                    }

                    var patternLength = song.GetPatternLength(p); 

                    for (var it = pattern.GetNoteIterator(0, patternLength); !it.Done; )
                    {
                        var time = it.CurrentTime;
                        var note = it.CurrentNote;

                        if (note == null)
                            note = emptyNote;

                        // We don't allow delaying speed effect at the moment.
                        if (isSpeedChannel && song.UsesFamiTrackerTempo)
                        {
                            var speed = FindEffectParam(song, p, time, Note.EffectSpeed);
                            if (speed >= 0)
                            {
                                currentSpeed = speed;
                                songData.Add($"${0xfb:x2}");
                                songData.Add($"${(byte)speed:x2}");
                            }
                        }

                        if (OtherVrc7ChannelUsesCustomPatch(song, channel, instrument, p, time))
                        {
                            instrument = null;
                        }

                        it.Next();

                        if (note.HasNoteDelay)
                        {
                            songData.Add($"${0x6a:x2}");
                            songData.Add($"${note.NoteDelay - 1:x2}");
                            usesDelayedNotesOrCuts = true;

                            // HACK : A note delay will cause the famistudio_channel_update function to 
                            // decrease the reference note counter, so we need to bump it. This should have 
                            // been fixed in the SoundEngine by jumping to @no_ref, but this is a hot-fix 
                            // version and I dont want to change the assembly.
                            //numValidNotes++; MATTT : Fix it in engine and remove the hack.
                        }

                        if (note.HasVolume)
                        {
                            songData.Add($"${(byte)(0x70 | note.Volume):x2}");
                            usesVolumeTrack = true;
                        }

                        if (note.HasFinePitch)
                        {
                            songData.Add($"${0x68:x2}");
                            songData.Add($"${note.FinePitch:x2}");
                            usesPitchTrack = true;
                        }

                        if (note.HasVibrato)
                        {
                            // TODO: If note has attack, no point in setting the default vibrato envelope, instrument will do it anyway.
                            songData.Add($"${0x63:x2}");
                            songData.Add($"{lo}({vibratoEnvelopeNames[note.RawVibrato]})");
                            songData.Add($"{hi}({vibratoEnvelopeNames[note.RawVibrato]})");

                            if (note.RawVibrato == 0)
                                songData.Add($"${0x65:x2}");

                            usesVibrato = true;
                        }

                        if (note.IsMusical)
                        {
                            // Set/clear override when changing arpeggio
                            if (note.Arpeggio != arpeggio)
                            {
                                if (note != null || !note.HasAttack)
                                {
                                    songData.Add($"${0x64:x2}");

                                    if (note.Arpeggio == null)
                                    {
                                        songData.Add($"{lo}({noArpeggioEnvelopeName})");
                                        songData.Add($"{hi}({noArpeggioEnvelopeName})");
                                    }
                                    else
                                    {
                                        songData.Add($"{lo}({arpeggioEnvelopeNames[note.Arpeggio]})");
                                        songData.Add($"{hi}({arpeggioEnvelopeNames[note.Arpeggio]})");
                                    }
                                }

                                if (note.Arpeggio == null)
                                    songData.Add($"${0x66:x2}");

                                arpeggio = note.Arpeggio;
                                usesArpeggio = true;
                            }
                            // If same arpeggio, but note has an attack, reset it.
                            else if (note.HasAttack && arpeggio != null)
                            {
                                songData.Add($"${0x67:x2}");
                            }
                        }

                        if (note.HasDutyCycle)
                        {
                            songData.Add($"${0x69:x2}");
                            songData.Add($"${note.DutyCycle:x2}");
                            usesDutyCycleEffect = true;
                        }

                        if (note.HasFdsModSpeed)
                        {
                            songData.Add($"${0x6c:x2}");
                            songData.Add($"${(note.FdsModSpeed >> 0) & 0xff:x2}");
                            songData.Add($"${(note.FdsModSpeed >> 8) & 0xff:x2}");
                        }

                        if (note.HasFdsModDepth)
                        {
                            songData.Add($"${0x6d:x2}");
                            songData.Add($"${note.FdsModDepth:x2}");
                        }

                        if (note.HasCutDelay)
                        {
                            songData.Add($"${0x6b:x2}");
                            songData.Add($"${note.CutDelay:x2}");
                            usesDelayedNotesOrCuts = true;
                        }

                        if (note.IsValid)
                        {
                            // Instrument change.
                            if (note.IsMusical && note.Instrument != null)
                            {
                                if (note.Instrument != instrument)
                                {
                                    // Change saw volume if needed.
                                    if (channel.Type == ChannelType.Vrc6Saw && sawVolume != note.Instrument.Vrc6SawMasterVolume)
                                    {
                                        sawVolume = note.Instrument.Vrc6SawMasterVolume;
                                        sawVolumeChanged = true;

                                        songData.Add($"${0x6c:x2}");
                                        songData.Add($"${1 - sawVolume:x2}");
                                    }

                                    int idx = instrumentIndices[note.Instrument];
                                    songData.Add($"${(byte)(0x80 | (idx << 1)):x2}");
                                    instrument = note.Instrument;
                                }
                                else if(!note.HasAttack)
                                {
                                    // TODO: Remove note entirely after a slide that matches the next note with no attack.
                                    songData.Add($"${0x62:x2}");
                                }
                            }

                            int numNotes = 0;

                            if (kernel != FamiToneKernel.FamiStudio)
                            {
                                // Note -> Empty -> Note special encoding.
                                if (time < patternLength - 2)
                                {
                                    pattern.Notes.TryGetValue(time + 1, out var nextNote1);
                                    pattern.Notes.TryGetValue(time + 2, out var nextNote2);

                                    var valid1 = (nextNote1 != null && nextNote1.IsValid) || (isSpeedChannel && FindEffectParam(song, p, time + 1, Note.EffectSpeed) >= 0);
                                    var valid2 = (nextNote2 != null && nextNote2.IsValid) || (isSpeedChannel && FindEffectParam(song, p, time + 2, Note.EffectSpeed) >= 0);

                                    if (!valid1 && valid2)
                                    {
                                        it.Next();
                                        numNotes = 1;
                                    }
                                }
                            }

                            var emittedSlideNote = false;

                            if (note.IsSlideNote)
                            {
                                var noteTableNtsc = NesApu.GetNoteTableForChannelType(channel.Type, false, song.Project.ExpansionNumChannels);
                                var noteTablePal  = NesApu.GetNoteTableForChannelType(channel.Type, true,  song.Project.ExpansionNumChannels);

                                var found = true;
                                found &= channel.ComputeSlideNoteParams(note, p, time, currentSpeed, noteTableNtsc, false, true, out _, out int stepSizeNtsc, out _);
                                found &= channel.ComputeSlideNoteParams(note, p, time, currentSpeed, noteTablePal,  true,  true, out _, out int stepSizePal,  out _);

                                if (song.Project.UsesExpansionAudio || machine == MachineType.NTSC)
                                    stepSizePal = stepSizeNtsc;
                                else if (machine == MachineType.PAL)
                                    stepSizeNtsc = stepSizePal;

                                if (found)
                                {
                                    // Take the (signed) maximum of both notes so that we are garantee to reach our note.
                                    var stepSize = Math.Max(Math.Abs(stepSizeNtsc), Math.Abs(stepSizePal)) * Math.Sign(stepSizeNtsc);
                                    songData.Add($"${0x61:x2}");
                                    songData.Add($"${(byte)stepSize:x2}");
                                    songData.Add($"${EncodeNoteValue(c, note.Value):x2}");
                                    songData.Add($"${EncodeNoteValue(c, note.SlideNoteTarget):x2}*");
                                    usesSlideNotes = true;
                                    emittedSlideNote = true;
                                }
                            }

                            if (!emittedSlideNote)
                                songData.Add($"${EncodeNoteValue(c, note.Value, numNotes):x2}*");
                        }
                        else
                        {
                            int numEmptyNotes = 0;

                            while (!it.Done)
                            {
                                time = it.CurrentTime;
                                note = it.CurrentNote;

                                if (note == null)
                                    note = emptyNote;

                                if (OtherVrc7ChannelUsesCustomPatch(song, channel, instrument, p, time))
                                {
                                    instrument = null;
                                }

                                // TODO: Change this, this is a shit show.
                                if (numEmptyNotes >= maxRepeatCount || 
                                    note.IsValid        ||
                                    note.HasVolume      || 
                                    note.HasVibrato     ||
                                    note.HasFinePitch   ||
                                    note.HasDutyCycle   ||
                                    note.HasFdsModSpeed || 
                                    note.HasFdsModDepth ||
                                    note.HasNoteDelay   ||
                                    note.HasCutDelay    ||
                                    (isSpeedChannel && FindEffectParam(song, p, time, Note.EffectSpeed) >= 0))
                                {
                                    break;
                                }

                                numEmptyNotes++;
                                it.Next();
                            }

                            songData.Add($"${(byte)(0x81 | (numEmptyNotes << 1)):x2}*");
                        }
                    }
                }

                if (song.LoopPoint < 0)
                {
                    songData.Add($"{ll}song{songIdx}ch{c}loop:");
                    songData.Add($"${EncodeNoteValue(c, Note.NoteStop):x2}");
                }

                songData.Add("$fd");
                songData.Add($"{ll}song{songIdx}ch{c}loop");
            }

            return songData;
        }

        // minNotesForJump is the minimum of notes to even consider doing a jump back to a reference. 
        int CompressAndOutputSongData(List<string> data, int minNotesForJump, bool writeLines)
        {
            bool IsLabelOrRef(string str) => str[0] == ll[0];
            bool IsLabel(string str) => str[str.Length - 1] == ':';
            bool IsRef(string str) => str[0] == ll[0] && str[str.Length - 1] != ':';
            bool IsNote(string str) => str[str.Length - 1] == '*';
            string CleanNote(string str) => str.TrimEnd('*');

            // Number of bytes to hash to start searching.
            const int HashNumBytes = 4;

            var refs = new HashSet<int>();
            var jumpToRefs = new HashSet<int>();
            var patterns = new Dictionary<uint, List<int>>();
            var compressedData = new List<string>();

            for (int i = 0; i < data.Count;)
            {
                var crc = 0u;
                var foundLabelOrRef = false;

                // Look ahead 4 bytes and compute hash.
                for (int k = i; k < data.Count && k < i + HashNumBytes; k++)
                {
                    var b = data[k];

                    if (IsLabelOrRef(b))
                    {
                        foundLabelOrRef = true;
                        break;
                    }

                    crc = CRC32.Compute(b, crc);
                }

                if (!foundLabelOrRef)
                { 
                    // Look at all the patterns matching the hash, take the longest.
                    if (patterns.TryGetValue(crc, out var matchingPatterns))
                    {
                        var bestPatternIdx = -1;
                        var bestPatternLen = -1;
                        var bestPatternNumNotes = -1;

                        foreach (var idx in matchingPatterns)
                        {
                            var lastNoteIdx = -1;
                            var numNotes = 0;

                            for (int j = idx, k = i; j < compressedData.Count && k < data.Count && numNotes < 250; j++, k++)
                            {
                                if (compressedData[j] != data[k] || IsLabelOrRef(compressedData[j]))
                                    break;

                                if (IsNote(compressedData[j]))
                                {
                                    numNotes++;
                                    lastNoteIdx = j;
                                }
                            }

                            if (numNotes >= minNotesForJump)
                            {
                                var matchLen = lastNoteIdx - idx + 1;
                                if (matchLen > bestPatternLen)
                                {
                                    bestPatternIdx = idx;
                                    bestPatternLen = matchLen;
                                    bestPatternNumNotes = numNotes;
                                }
                            }
                        }

                        // Output a jump to a ref if we found a good match.
                        if (bestPatternIdx > 0)
                        {
                            refs.Add(bestPatternIdx);
                            jumpToRefs.Add(compressedData.Count);

                            compressedData.Add("$ff");
                            compressedData.Add($"${bestPatternNumNotes:x2}");
                            compressedData.Add($"{ll}ref{bestPatternIdx}");

                            i += bestPatternLen;
                        }
                        else
                        {
                            compressedData.Add(data[i]);
                            i++;
                        }
                    }
                    else
                    {
                        compressedData.Add(data[i]);
                        i++;
                    }
                }
                else
                {
                    compressedData.Add(data[i]);
                    i++;
                }

                // Keep hash of compressed data.
                if (compressedData.Count >= HashNumBytes)
                {
                    crc = 0u;

                    var startHashIdx = compressedData.Count - HashNumBytes;
                    for (int j = startHashIdx; j < compressedData.Count; j++)
                        crc = CRC32.Compute(compressedData[j], crc);

                    if (!patterns.TryGetValue(crc, out var list))
                    {
                        list = new List<int>();
                        patterns.Add(crc, list);
                    }

                    list.Add(startHashIdx);
                }
            }

            // Output the assembly code.
            var size = 0;
            string byteString = null;

            for (int i = 0; i < compressedData.Count; i++)
            {
                var b = CleanNote(compressedData[i]);

                var isRef = refs.Contains(i);
                var isLabel = IsLabel(b);
                var isJumpCode = jumpToRefs.Contains(i);
                var isJumpLabel = IsRef(b);

                if (byteString != null && (isJumpLabel || isLabel || isRef || isJumpCode))
                {
                    if (writeLines)
                        lines.Add(byteString);
                    byteString = null;
                }

                if (isRef)
                {
                    if (writeLines)
                        lines.Add($"{ll}ref{i}:");
                }

                if (isLabel)
                {
                    if (writeLines)
                        lines.Add(b);
                }
                else if (isJumpLabel)
                {
                    if (writeLines)
                        lines.Add($"\t{dw} {b}");
                    size += 2;
                }
                else
                {
                    if (byteString == null)
                        byteString = $"\t{db} {b}";
                    else
                        byteString += $", {b}";
                    size++;
                }
            }

            return size;
        }

        private int ProcessAndOutputSong(int songIdx)
        {
            var song = project.Songs[songIdx];

            // Take the channel with the most speed effect as the speed channel.
            // This was a really dumb optimization in FT2...
            var speedEffectCount = new int[song.Channels.Length];
            for (int c = 0; c < song.Channels.Length; c++)
            {
                foreach (var pattern in song.Channels[c].Patterns)
                {
                    foreach (var note in pattern.Notes.Values)
                    {
                        if (note.HasSpeed)
                            speedEffectCount[c]++;
                    }
                }
            }

            int speedChannel = 0;
            int maxSpeedEffects = 0;
            for (int c = 0; c < song.Channels.Length; c++)
            {
                if (speedEffectCount[c] > maxSpeedEffects)
                {
                    maxSpeedEffects = speedEffectCount[c];
                    speedChannel = c;
                }
            }

            // Get raw uncompressed song data.
            var songData = GetSongData(song, songIdx, speedChannel);

            // Try compression with various threshold for jump to ref.
            var bestSize = int.MaxValue;
            var bestMinNotesForJump = 0;

            for (int i = 8; i < 32; i++)
            {
                var size = CompressAndOutputSongData(songData, i, false);
#if DEBUG
                Log.LogMessage(LogSeverity.Info, $"Compression with a match of {i} notes = {size} bytes.");
#endif

                if (size < bestSize)
                {
                    bestSize = size;
                    bestMinNotesForJump = i;
                }
            }

            return CompressAndOutputSongData(songData, bestMinNotesForJump, true);
        }
        
        private void SetupFormat(int format)
        {
            assemblyFormat = format;

            switch (format)
            {
                case AssemblyFormat.NESASM:
                    db = ".db";
                    dw = ".dw";
                    ll = ".";
                    lo = "LOW";
                    hi = "HIGH";
                    break;
                case AssemblyFormat.CA65:
                    db = ".byte";
                    dw = ".word";
                    ll = "@";
                    lo =  ".lobyte";
                    hi =  ".hibyte";
                    break;
                case AssemblyFormat.ASM6:
                    db = "db";
                    dw = "dw";
                    ll = "@";
                    lo = "<";
                    hi = ">";
                    break;
            }
        }

        private void RemoveUnsupportedFeatures()
        {
            foreach (var song in project.Songs)
            {
                foreach (var channel in song.Channels)
                {
                    foreach (var pattern in channel.Patterns)
                    {
                        foreach (var note in pattern.Notes.Values)
                        {
                            // FamiTone2 supports very few effects.
                            if (kernel == FamiToneKernel.FamiTone2)
                            { 
                                if (note.IsRelease)
                                    note.Value = Note.NoteInvalid;

                                note.HasAttack    = true;
                                note.HasVibrato   = false;
                                note.HasVolume    = false;
                                note.IsSlideNote  = false;
                                note.HasFinePitch = false;
                                note.HasDutyCycle = false;
                                note.HasNoteDelay = false;
                                note.HasCutDelay  = false;
                                note.Arpeggio     = null;
                            }
                            else
                            {
                                // Note delays for empty notes are useless and will only confuse the exporter.
                                // We also don't support delays on speed effects.
                                if (note.HasNoteDelay && (!note.IsValid && (note.EffectMask & (~(Note.EffectNoteDelayMask | Note.EffectSpeed))) == 0))
                                {
                                    note.HasNoteDelay = false;
                                }
                            }
                        }
                    }
                }
            }

            // Empty arpeggios confuses the exporter.
            for (int i = 0; i < project.Arpeggios.Count; )
            {
                var arp = project.Arpeggios[i];
                if (arp.Envelope.IsEmpty(EnvelopeType.Arpeggio))
                {
                    project.DeleteArpeggio(arp);
                }
                else
                {
                    i++;
                }
            }

            // Remove releases in envelopes + expansion audio for FamiTone2.
            if (kernel == FamiToneKernel.FamiTone2)
            {
                foreach (var instrument in project.Instruments)
                {
                    var env = instrument.Envelopes[EnvelopeType.Volume];
                    if (env.Release >= 0)
                    {
                        env.Length  = env.Release;
                        env.Release = -1;
                    }
                }

                project.SetExpansionAudio(ExpansionType.None);
            }
        }

        private void SetupProject(Project originalProject, int[] songIds)
        {
            // Work on a temporary copy.
            project = originalProject.DeepClone();
            project.Filename = originalProject.Filename;

            if (kernel == FamiToneKernel.FamiTone2 && project.UsesFamiStudioTempo)
            {
                project.ConvertToFamiTrackerTempo(false);
            }

            // NULL = All songs.
            if (songIds != null)
            {
                for (int i = 0; i < project.Songs.Count; i++)
                {
                    if (!songIds.Contains(project.Songs[i].Id))
                    {
                        project.DeleteSong(project.Songs[i]);
                        i--;
                    }
                }
            }

            RemoveUnsupportedFeatures();
            project.DeleteUnusedInstruments(); 
        }

        private void OutputIncludeFile(string includeFilename)
        {
            var includeLines = new List<string>();

            for (int songIdx = 0; songIdx < project.Songs.Count; songIdx++)
            {
                var song = project.Songs[songIdx];
                includeLines.Add($"song_{Utils.MakeNiceAsmName(song.Name)} = {songIdx}");
            }
            includeLines.Add($"song_max = {project.Songs.Count}");

            // For CA65, also include song names.
            if (assemblyFormat == AssemblyFormat.CA65)
            {
                includeLines.Add("");
                includeLines.Add(".if SONG_STRINGS");
                includeLines.Add("song_strings:");

                foreach (var song in project.Songs)
                {
                    includeLines.Add($".asciiz \"{song.Name}\"");
                }

                includeLines.Add(".endif");
            }

            File.WriteAllLines(includeFilename, includeLines.ToArray());
        }

        public bool Save(Project originalProject, int[] songIds, int format, bool separateSongs, string filename, string dmcFilename, string includeFilename, int machine)
        {
            this.machine = machine;
            SetupProject(originalProject, songIds);
            SetupFormat(format);
            CleanupEnvelopes();

            var dmcSize    = OutputSamples(filename, dmcFilename);
            var headerSize = OutputHeader(separateSongs);
            var instSize   = OutputInstruments();
            var tempoSize  = OutputTempoEnvelopes();

            if (log)
            {
                Log.LogMessage(LogSeverity.Info, $"Header size : {headerSize} bytes.");
                Log.LogMessage(LogSeverity.Info, $"Instruments size : {instSize} bytes.");
                Log.LogMessage(LogSeverity.Info, $"Tempo envelopes size : {tempoSize} bytes.");
            }

            var totalSongsSize = 0;
            for (int i = 0; i < project.Songs.Count; i++)
            {
                var songSize = ProcessAndOutputSong(i);
                totalSongsSize += songSize;

                if (log)
                    Log.LogMessage(LogSeverity.Info, $"Song '{project.Songs[i].Name}' size: {songSize} bytes.");
            }

            File.WriteAllLines(filename, lines);

            if (includeFilename != null)
            {
                OutputIncludeFile(includeFilename);
            }

            if (log)
            {
                Log.LogMessage(LogSeverity.Info, $"Total assembly file size: {headerSize + instSize + tempoSize + totalSongsSize} bytes.");

                if (project.UsesSamples)
                    Log.LogMessage(LogSeverity.Info, $"Total dmc file size: {dmcSize} bytes.");

                if (kernel == FamiToneKernel.FamiStudio)
                {
                    if (usesFamiTrackerTempo)
                        Log.LogMessage(LogSeverity.Info, "Project uses FamiTracker tempo, you must set FAMISTUDIO_USE_FAMITRACKER_TEMPO = 1.");
                    if (usesDelayedNotesOrCuts)
                        Log.LogMessage(LogSeverity.Info, "Project uses delayed notes or cuts, you must set FAMISTUDIO_USE_FAMITRACKER_DELAYED_NOTES_OR_CUTS = 1.");
                    if (usesVolumeTrack)
                        Log.LogMessage(LogSeverity.Info, "Volume track is used, you must set FAMISTUDIO_USE_VOLUME_TRACK = 1.");
                    if (usesPitchTrack)
                        Log.LogMessage(LogSeverity.Info, "Fine pitch track is used, you must set FAMISTUDIO_USE_PITCH_TRACK = 1.");
                    if (usesSlideNotes)
                        Log.LogMessage(LogSeverity.Info, "Slide notes are used, you must set FAMISTUDIO_USE_SLIDE_NOTES = 1.");
                    if (usesVibrato)
                        Log.LogMessage(LogSeverity.Info, "Vibrato effect is used, you must set FAMISTUDIO_USE_VIBRATO = 1.");
                    if (usesArpeggio)
                        Log.LogMessage(LogSeverity.Info, "Arpeggios are used, you must set FAMISTUDIO_USE_ARPEGGIO = 1.");
                    if (usesDutyCycleEffect)
                        Log.LogMessage(LogSeverity.Info, "Duty Cycle effect is used, you must set FAMISTUDIO_USE_DUTYCYCLE_EFFECT = 1.");
                }
            }

#if DEBUG
            Debug.Assert(GetAsmFileSize(lines) == headerSize + instSize + tempoSize + totalSongsSize);
#endif

            return true;
        }

#if DEBUG
        private int GetAsmFileSize(List<string> lines)
        {
            int size = 0;

            foreach (var line in lines)
            {
                var trimmedLine = line.Trim();

                int commentIdx = trimmedLine.IndexOf(';');
                if (commentIdx >= 0)
                    trimmedLine = trimmedLine.Substring(0, commentIdx);

                bool isByte = trimmedLine.StartsWith("db") || trimmedLine.StartsWith(".db") || trimmedLine.StartsWith(".byte");
                bool isWord = trimmedLine.StartsWith("dw") || trimmedLine.StartsWith(".dw") || trimmedLine.StartsWith(".word");

                if (isByte || isWord)
                {
                    var splits = trimmedLine.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    size += splits.Length * (isWord ? 2 : 1);
                }
            }

            return size;
        }
#endif

        public static byte[] ParseAsmFile(string filename, int songOffset, int dpcmOffset)
        {
            var labels = new Dictionary<string, int>();
            var labelsToPatch = new List<Tuple<string, int>>();
            var bytes = new List<byte>();

            string[] lines = File.ReadAllLines(filename);

            foreach (var line in lines)
            {
                var trimmedLine = line.Trim();

                int commentIdx = trimmedLine.IndexOf(';');
                if (commentIdx >= 0)
                {
                    trimmedLine = trimmedLine.Substring(0, commentIdx);
                }

                bool isByte = trimmedLine.StartsWith("db");
                bool isWord = trimmedLine.StartsWith("dw");

                if (isByte || isWord)
                {
                    var splits = trimmedLine.Substring(3).Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    for (int i = 0; i < splits.Length; i++)
                    {
                        var hex = false;
                        var valStr = splits[i].Trim();
                        var valNum = 0;

                        if (valStr.StartsWith("$"))
                        {
                            hex = true;
                            valStr = valStr.Substring(1).Trim();
                        }

                        if (valStr.StartsWith("<(") || valStr.StartsWith(">("))
                        {
                            // We only use those for vibrato right now.
                            bool lobyte = valStr.StartsWith("<(");
                            valStr = valStr.Substring(2, valStr.Length - 3);

                            if (labels.ContainsKey(valStr))
                                valNum = lobyte ? (labels[valStr] & 0xff) : (labels[valStr] >> 8);
                            else if (lobyte)
                                labelsToPatch.Add(new Tuple<string, int>(valStr, bytes.Count));
                        }
                        else if (labels.ContainsKey(valStr))
                        {
                            valNum = labels[valStr];
                        }
                        else
                        {
                            if (valStr.StartsWith("@"))
                            {
                                labelsToPatch.Add(new Tuple<string, int>(valStr, bytes.Count));
                            }
                            else if (valStr.Contains("FT_DPCM_PTR") || valStr.Contains("FAMISTUDIO_DPCM_PTR"))
                            {
                                valNum = Convert.ToInt32(valStr.Split('+')[0], 16) + ((dpcmOffset & 0x3fff) >> 6);
                            }
                            else
                            {
                                valNum = Convert.ToInt32(valStr, hex ? 16 : 10);
                            }
                        }

                        if (isByte)
                        {
                            bytes.Add((byte)(valNum & 0xff));
                        }
                        else
                        {
                            bytes.Add((byte)((valNum >> 0) & 0xff));
                            bytes.Add((byte)((valNum >> 8) & 0xff));
                        }
                    }
                }
                else if (trimmedLine.EndsWith(":"))
                {
                    labels[trimmedLine.TrimEnd(':')] = bytes.Count + songOffset;
                }
            }

            foreach (var pair in labelsToPatch)
            {
                int val;
                if (pair.Item1.Contains("-"))
                {
                    var splits = pair.Item1.Split('-');
                    val = labels[splits[0]];
                    val -= Convert.ToInt32(splits[1]);
                }
                else
                {
                    val = labels[pair.Item1];
                }

                bytes[pair.Item2 + 0] = ((byte)((val >> 0) & 0xff));
                bytes[pair.Item2 + 1] = ((byte)((val >> 8) & 0xff));
            }

            return bytes.ToArray();
        }

        // HACK: This is pretty stupid. We write the ASM and parse it to get the bytes. Kind of backwards.
        public byte[] GetBytes(Project project, int[] songIds, int songOffset, int dpcmOffset, int machine)
        {
            var tempFolder = Utils.GetTemporaryDiretory();
            var tempAsmFilename = Path.Combine(tempFolder, "nsf.asm");
            var tempDmcFilename = Path.Combine(tempFolder, "nsf.dmc");

            Save(project, songIds, AssemblyFormat.ASM6, false, tempAsmFilename, tempDmcFilename, null, machine);

            return ParseAsmFile(tempAsmFilename, songOffset, dpcmOffset);
        }
    }

    public static class AssemblyFormat
    {
        public const int NESASM = 0;
        public const int CA65   = 1;
        public const int ASM6   = 2;

        public static readonly string[] Names =
        {
            "NESASM",
            "CA65",
            "ASM"
        };

        public static int GetValueForName(string str)
        {
            return Array.IndexOf(Names, str);
        }
    };

    public static class FamiToneKernel
    {
        public const int FamiTone2  = 0; // Stock FamiTone2
        public const int FamiStudio = 1; // Heavily modified version that supports every FamiStudio feature.

        public static readonly string[] Names =
        {
            "FamiTone2",
            "FamiStudio"
        };

        public static int GetValueForName(string str)
        {
            return Array.IndexOf(Names, str);
        }
    };

}
